---**Toggle when implementing AI-generated Trogdor images with Replicate API.**

## Replicate Setup
```typescript
// src/lib/replicate.ts
import Replicate from 'replicate';

const replicate = new Replicate({
  auth: process.env.REPLICATE_API_TOKEN!,
});

export default replicate;
```

## Model Selection
- **Stable Diffusion XL**: stability-ai/sdxl
- **Best for Trogdor**: Simple, crude, sketch-style generations
- Alternative: flux-schnell for faster generations

## Image Generation Flow

### 1. Create Prediction
```typescript
async function generateTrogdorImage(userPrompt: string) {
  // Enhance prompt with Trogdor style
  const enhancedPrompt = enhancePrompt(userPrompt);
  
  const prediction = await replicate.predictions.create({
    version: "stability-ai/sdxl:39ed52f2a78e934b3ba6e2a89f5b1c712de7dfea535525255b1aa35c5565e08b",
    input: {
      prompt: enhancedPrompt,
      negative_prompt: "photorealistic, polished, professional, detailed, HD, 4K, realistic, photography",
      width: 1024,
      height: 1024,
      num_outputs: 1,
      guidance_scale: 7.5,
      num_inference_steps: 25,
    },
  });
  
  return prediction;
}
```

### 2. Prompt Enhancement
```typescript
function enhancePrompt(userPrompt: string): string {
  const styleKeywords = [
    "crude drawing",
    "childish sketch",
    "MS Paint style",
    "amateur art",
    "simple lines",
    "comic style dragon",
    "stick figure aesthetic",
  ];
  
  const randomStyle = styleKeywords[Math.floor(Math.random() * styleKeywords.length)];
  
  return `${userPrompt}, ${randomStyle}, TROGDOR the dragon with one beefy arm, consummate V's, simple pencil sketch, white background`;
}
```

### 3. Poll for Completion
```typescript
async function waitForPrediction(predictionId: string) {
  let prediction = await replicate.predictions.get(predictionId);
  
  while (prediction.status === 'starting' || prediction.status === 'processing') {
    await new Promise(resolve => setTimeout(resolve, 1000)); // Poll every 1s
    prediction = await replicate.predictions.get(predictionId);
  }
  
  if (prediction.status === 'failed') {
    throw new Error(`Generation failed: ${prediction.error}`);
  }
  
  return prediction;
}
```

### 4. Complete API Route
```typescript
// app/api/generate/route.ts
export async function POST(req: Request) {
  const session = await getServerSession();
  if (!session) return new Response('Unauthorized', { status: 401 });
  
  const { prompt } = await req.json();
  
  // Validate prompt
  if (!prompt || prompt.length < 10 || prompt.length > 500) {
    return Response.json({ error: 'Invalid prompt' }, { status: 400 });
  }
  
  // Rate limit check
  const canGenerate = await checkRateLimit(session.user.id, 10, 3600000); // 10/hour
  if (!canGenerate) {
    return Response.json({ error: 'Rate limit exceeded' }, { status: 429 });
  }
  
  try {
    // Create prediction
    const prediction = await generateTrogdorImage(prompt);
    
    // Store in database
    const [generation] = await db.insert(generations)
      .values({
        userId: session.user.id,
        prompt: prompt,
        enhancedPrompt: prediction.input.prompt,
        replicateId: prediction.id,
        status: 'processing',
      })
      .returning();
    
    return Response.json({ 
      id: generation.id, 
      replicateId: prediction.id,
      status: 'processing' 
    });
    
  } catch (error) {
    console.error('Generation error:', error);
    return Response.json({ error: 'Generation failed' }, { status: 500 });
  }
}
```

## Webhook Handler (Recommended)
```typescript
// app/api/webhooks/replicate/route.ts
export async function POST(req: Request) {
  const { id, status, output, error } = await req.json();
  
  // Find generation record
  const [generation] = await db.select()
    .from(generations)
    .where(eq(generations.replicateId, id))
    .limit(1);
  
  if (!generation) {
    return new Response('Not found', { status: 404 });
  }
  
  if (status === 'succeeded' && output?.[0]) {
    // Download image from Replicate's CDN
    const imageUrl = output[0];
    const imageBuffer = await fetch(imageUrl).then(r => r.arrayBuffer());
    
    // Upload to your storage (R2/S3)
    const storageUrl = await uploadToStorage(imageBuffer, generation.id);
    
    // Update database
    await db.update(generations)
      .set({
        status: 'completed',
        imageUrl: storageUrl,
        completedAt: new Date(),
      })
      .where(eq(generations.id, generation.id));
  } else if (status === 'failed') {
    await db.update(generations)
      .set({
        status: 'failed',
        error: error,
      })
      .where(eq(generations.id, generation.id));
  }
  
  return new Response('OK', { status: 200 });
}
```

## Database Schema
```typescript
export const generations = pgTable('generations', {
  id: serial('id').primaryKey(),
  userId: integer('user_id').references(() => users.id).notNull(),
  prompt: text('prompt').notNull(),
  enhancedPrompt: text('enhanced_prompt').notNull(),
  replicateId: text('replicate_id').notNull().unique(),
  status: text('status').notNull(), // processing, completed, failed
  imageUrl: text('image_url'),
  error: text('error'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  completedAt: timestamp('completed_at'),
}, (table) => ({
  userIdx: index('gen_user_idx').on(table.userId),
  statusIdx: index('gen_status_idx').on(table.status),
}));
```

## Client Component
```typescript
'use client';
export function ImageGenerator() {
  const [prompt, setPrompt] = useState('');
  const [loading, setLoading] = useState(false);
  const [generationId, setGenerationId] = useState<number | null>(null);
  
  const handleGenerate = async () => {
    setLoading(true);
    
    const response = await fetch('/api/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ prompt }),
    });
    
    const data = await response.json();
    setGenerationId(data.id);
    
    // Poll for completion
    pollForCompletion(data.id);
  };
  
  const pollForCompletion = async (id: number) => {
    const interval = setInterval(async () => {
      const response = await fetch(`/api/generate/${id}`);
      const data = await response.json();
      
      if (data.status === 'completed') {
        clearInterval(interval);
        setLoading(false);
        // Show image
      } else if (data.status === 'failed') {
        clearInterval(interval);
        setLoading(false);
        // Show error
      }
    }, 2000); // Poll every 2 seconds
  };
  
  return (
    <div>
      <textarea 
        value={prompt} 
        onChange={(e) => setPrompt(e.target.value)}
        placeholder="Describe your Trogdor scene..."
      />
      <button onClick={handleGenerate} disabled={loading}>
        {loading ? 'Generating...' : 'Generate'}
      </button>
    </div>
  );
}
```

## Cost Optimization
- Cache popular prompts in Redis
- Implement user credits/limits
- Use lower-cost models when possible
- Batch requests during off-peak hours
- Set reasonable rate limits (10/hour per user)

## Error Handling
```typescript
if (prediction.status === 'failed') {
  // Common errors:
  // - NSFW content detected
  // - Invalid prompt
  // - Server timeout
  
  await db.update(generations)
    .set({ 
      status: 'failed', 
      error: prediction.error 
    })
    .where(eq(generations.id, generationId));
}
```

## Rate Limiting
- Free users: 5 generations/day
- Premium users: 50 generations/day
- Max concurrent: 3 per user
- Store limits in Redis with daily reset

## Image Storage
- Don't rely on Replicate CDN (temporary)
- Upload to Cloudflare R2 or S3
- Generate thumbnail (512x512)
- Store both full and thumbnail URLs
- Set CDN cache headers for public images

## Testing
- Test with simple prompts first
- Verify negative prompts work
- Check rate limiting
- Test webhook delivery
- Validate image storage
- Monitor generation times (avg 10-30s)

## Prompt Safety
- Filter profanity
- Block NSFW keywords
- Limit special characters
- Max prompt length: 500 chars
- Log suspicious prompts for review
